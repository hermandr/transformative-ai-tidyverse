---
title: "Permuted Event Window"
author: "Your Name"
date: today
format: html
editor: visual
execute:
  warning: false
  echo: false
---

```{r}
source(here::here("_common.R"))
```

## Data Preparation

### Data Processing

#### Load raw data

#### FRED Data on Treasury Bonds

```{r}
bond_metadata <- read_csv(here("data/raw/bond_metadata.csv"), show_col_types = FALSE)
kable(bond_metadata)
```

#### `bond_yields` sampled rows

```{r}
bond_yields <- read_csv(here("data/raw/bond_yields_raw.csv"), show_col_types = FALSE)
kable(bond_yields |> slice_sample(n=10))
```

#### `ai_events` sampled rows

```{r}
ai_events <- read_csv(here("data/raw/ai_events_raw.csv"), show_col_types = FALSE) %>%
    mutate(
        date = as.Date(date), 
        year=as.integer(year)
    )

kable(ai_events |> slice_sample(n=10))
```

cat("Loaded", nrow(bond_yields), "bond yield observations\n") cat("Loaded", nrow(ai_events), "AI event dates\n")

#### `actual_event_long_window` sampled rows

```{r}
actual_event_long_window <- read_csv(here("data/processed/actual_event_long_window.csv"), show_col_types = FALSE) 
kable(actual_event_long_window |> slice_sample(n=10))
```

## Placebo Permutated Inference

Global: `dt` dataframe Input: `events` dataframe Output: 31 rows per symbol of median price changes

### Prepare Globals

#### Trading Dates

```{r}
trading_dates = bond_yields |> 
    filter(symbol=="DGS10") |> 
    # If DGS10 exists, it's a trading day
    filter(!is.na(price)) |> 
    select(date)

trading_dates |> slice_sample(n=10) |> kable()
```

### Build Event Windows

Steps:

1.  Create dataframe of trading dates from the yields table based on `DGS10` data
2.  As the dates will not be sequential, assign a row id as a sequence
3.  Select the trading dates from the yields table
4.  Impute missing data
5.  For each AI event date create a dataframe of yields prices from -15 days to +15 days after event date

#### Trading Dates

```{r}
trading_dates = bond_yields |> 
    filter(symbol=="DGS10") |> 
    # If DGS10 exists, it's a trading day
    filter(!is.na(price)) |> 
    select(date)

trading_dates |> slice_sample(n=10) |> kable()
```

#### Assign Row ID

```{r}
trading_dates = trading_dates |>  
    arrange(date) |> 
    rowid_to_column(var="trading_day_index")

trading_dates |> slice_sample(n=10) |> kable()
```

#### Yields data for trading dates

```{r}
yields = bond_yields |> 
    inner_join(trading_dates)

yields |> slice_sample(n=10) |> kable()

```

#### Final

```{r}
dt = yields
dt |> slice_sample(n=4) |> kable()
```

### Placebo Event Dates Replicates

#### Candidate Placebo Event Dates

```{r}
placebo_dates = trading_dates  |> 
    anti_join(ai_events, by = "date") 
```

```{r}
num_events = nrow(ai_events)
replicates = tibble(rep_id = seq(1,5000)) |> 
    mutate(
        event_dates = map(rep_id, ~ placebo_dates |> slice_sample(n=num_events))
    )
```

#### AI Event Dates Event Study Windows

```{r}
source(here::here("dev/process_one_events_set.R"))
```

```{r}
library(furrr)

# Set up parallel processing
plan(multisession, workers = availableCores() - 1)  # Leave one core free

# Parallel version of your code
rep_data <- replicates |> 
    mutate(
        placebo_events = future_map(event_dates, \(df) {
            df |> 
                arrange(date) |> 
                rowid_to_column(var="event_id") |> 
                inner_join(trading_dates) |> 
                select(event_id, event_date = date, event_date_index = trading_day_index)
        }, 
            .options = furrr_options(seed = TRUE),
            .progress = TRUE
        ),
        plot_data = future_map(placebo_events, \(df) {
            result = process_one_events_set(df, 15, dt)
            return(result[[2]])
        }, 
            .options = furrr_options(seed = TRUE),
            .progress = TRUE
        )
    )

# Clean up when done
plan(sequential)
```

```{r}
placebo_data = rep_data |> 
    pull(plot_data) |> 
    list_rbind(names_to = "rep_id")
```

`data` now has 5000 replicates of each symbol, window_index

```{r}
placebo_data |> group_by(symbol, window_index) |> count()
```

#### Save Placebo Data

```{r}
write_csv(placebo_data, here("data/processed/placebo_long_window.csv"))
```